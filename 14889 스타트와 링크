https://www.acmicpc.net/problem/14889

결과적으로, 답이 O(2^n)을 훌쩍 뛰어넘는 시간 복잡도를 보이는데 이보다 효율적인 코드가 없다는 것이 놀라운 문제.

총 짝수인 N명이 모임. N/2명의 두 개의 팀으로 나눔. 이름은 각각 스타트팀과 링크팀.
정사각형 2D 배열의 행과 열에 사람들을 각각 나열해두고, i와 j가 만났을 때의 팀 케미를 성분으로 채워넣는다.
신기하게도 (i,j)의 값과 (j,i)의 값은 다를 수 있다. 어찌됐든 i와 j가 한 팀이 된다면, 팀에는 (i,j)와 (j,i)가 모두 더해진다.
축구를 재미있게 하기 위해서 각 팀의 능력치 차이를 최소화하려고 한다.

(n^2-n)/2 만큼의 배열을 만들어 (i,j)와 (j,i)의 합을 더한 값을 각각에 넣는다.
이제 이 문제는 그 배열의 수들을 총 합이 서로 가장 비슷한 같은 사이즈의 두 개의 그룹으로 나누는 문제로 break down 된 줄 알았는데 아니다.

4명 케이스: 21 31 41 32 42 43                            => 21 43 / 31 42 / 41 32
6명 케이스: 21 31 41 51 61 32 42 52 62 43 53 63 54 64 65 => 21+31+32 54+64+65 / ...

어떻게 풀어야 할까? 방법을 새로 구축해보자. 분명 더 좋은 풀이법이 있을 것 같긴 한데, 시중에 유통되는 풀이를 일단을 따르자.
기본적으로는, 무작위로 n명을 n/2의 두 개의 팀으로 나누고, 해당 팀 사이 힘의 차이의 최솟값을 구하는 순서로 갈 것이다.
기술적으로 관심을 기울여야 할 부분은 n명을 두 팀으로 나누는 부분이다.

이 부분에서 크게 두 가지의 방법을 사용할 수 있다.
1. 재귀 recursion (DFS): n명을 2개의 팀으로 나누는 경우의 수, 즉 2^n의 시간복잡도. 재귀는 스택을 이용하므로 n은 20 이하로 관리.
이 구현은 기술적으로 탐탁지가 않다. 너무 조잡하고 직관적이지가 않다.
2. 순열 permutation: 0과 1을 각각 n/2개 씩 가지고 계속 돌려보는 것. 예를 들어 n=4면 0011 다음은 0101인 것이다.
기술적인 부분에서는 next_permutation(v.begin(), v.end()) 함수가 눈에 띈다. 지가 알아서 순차적으로 다음 크기의 순열을 보이는 것.

이렇게 두 개의 방법 중 어느 쪽을 사용해도 무방하다. 디테일을 놓치지 않는 것이 중요할 텐데.
나중에 디테일까지 살려서 다시 한 번 풀어보고 싶은 문제.
